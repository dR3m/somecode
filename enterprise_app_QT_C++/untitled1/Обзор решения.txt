Обзор решения.

Структура БД:

таблица stuff(id integer primary key, name varchar, start_date date, base_rate integer, type integer) - основаная талица, содержащая главную инфу о сотрудниках
таблица positions(type integer primary key, description varchar) - вспомагательная таблица для граф. интерфейса
таблица who_boss(id integer, boss_id integer) - таблица соотношений подчинённый-босс

Структора кода:
DataBase(sql_bd.h/cpp) - класс работающий с запросами в базу
    int addWorker - добавляет сотрудника, выставляя имя, дату начала работы, баз. ставку и должность, вернёт  id сотрудника в бд 
    bool setBoss - выставит босса сотрудника, не проверяет должность босса (employer не мб боссом), т.к. это ограничение обеспечивается при реализации граф. интерфейса.
    bool setPosition - поменяет должность;
    QSqlQuery getSlaves(int worker_id) - вернёт результат запроса всех подчинённых из бд
    QSqlQuery getSlaves(int worker_id, int level) - тоже самое, только в запросе укажет должность подчинённого
    QSqlQuery getAllStuff() - вернёт id всех сотрудников
    QSqlRecord getData(int id) - вернёт главную инфу о сотруднике
    int calculateAllStuffSalary(QDate some_date) - расчёт суммарной зп всех сотрудников на указанный временной период. Метод был определён в классе DataBase, т.к. такой функционал кажется НЕправильным разместить для конкретного типа сотрудников.   
    QSqlError initDb() - приватный метод, инициализирующий бд, создающий таблицы, если они отсуствуют

Worker(Worker.h) - родительский класс для всех типов сотрудников. В классе определён только конструктор и метод experience(Qdate d)(расчёт стажа на произвольный момент времени), т.к. у всех типов сотрудников эти процедуры одинаковы. Остальные методы calculateSalary(), countSlaves() - виртуальные и будут переопределены в наследниках.
Каждый сотрудник определяется id, именем, датой принятия на работу, базовой ставкой. Соотвественно полям  int id, string name, QDate start_date, int base_salary в классе.

Employer - класс наследник Worker'a. Т.к. у employer'а не может быть подчинённых, 
	countSlaves() просто сделает return 0.
	calculateSalary() - посчитает зп для сотридника на указанный момент времени

Manager - класс наследник Worker'a. 
	countSlaves() вернёт сумму 0.5% от зп каждого подчинённого 0-типа
	calculateSalary() -"-

Employer - класс наследник Worker'a. 
	countSlaves() вернёт сумму 0.3% от зп каждого подчинённого любого типа.
	calculateSalary() -"-

Упрощённые и недоработанные места:
В расчёте стажа не учитывается високосный год.
Проверка того, что пользователь с id определённый в одном из классов Employer, Manager, Sales, дествительно является сотрудником соотвествующего типа отсуствует. Т.к. такие ограничения предполагались интерфейсом.

в main.cpp  есть методы fillDB() для заполнения пустой бд и calcSalary() как пример подсчёта зп у сотрудников и общей зп.

Интерфейс:
Реализован самый простой функционал:
	-Отображение таблицы stuff с буквенным описанием должности
	-При двойном клике на строку в таблице - в нижних виджетат появятся список подчинённых и имя босса сотрудника(корректнее будет отображать id босса и имя босса)
	-Возможность добавить сотрудника указав имя, ставку, должность и начальника. Дата начала работы устанавливается на сегодняшнюю уже внитри кода.
	-Обновление списка сотрудников и списка начальников сразу после добавления нового
	-В списке начальников можно выбрать только сотрудников типа Sales, Manager

В функционале добавления сотрудника указывается id начальника, т.к. id однозначно определит босса, в отличии от имени. Корректнее будет писать и имя и id.

Проект создан-собран в Qt 4.8.0, GCC, OS Debian

